// import React, { useState, useEffect } from 'react';
// import { Card } from '@/components/ui/card';
// import { OverlappingVulnerability } from '@/types/vulnerabilities';
// import { 
//     NetRiskReductionData, 
//     VulnerabilityControlMappingProps,
//     CreateNetRiskReductionRequest 
// } from '@/types/netRiskReduction';
// import netRiskReductionService from '@/services/netRiskReduction';

// const VulnerabilityControlMappingCard: React.FC<VulnerabilityControlMappingProps> = ({
//   overlappingVulnerabilities,
//   controls,
//   userId,
//   organizationId,
//   totalRisk,
//   loading = false
//   // onDataChange
// }) => {
//   const [riskData, setRiskData] = useState<NetRiskReductionData[]>([]);
//   const [saving, setSaving] = useState(false);
//   const [dataLoading, setDataLoading] = useState(true);

//   useEffect(() => {
//     const loadRiskData = async () => {
//         // Only run if we have the required data
//         if (!userId || !organizationId || overlappingVulnerabilities.length === 0 || controls.length === 0) {
//         console.log('‚è∏Ô∏è Skipping risk data load - missing required data:', {
//             userId: !!userId,
//             organizationId: !!organizationId, 
//             vulnerabilitiesCount: overlappingVulnerabilities.length,
//             controlsCount: controls.length
//         });
//         setDataLoading(false);
//         return;
//         }

//         setDataLoading(true);

//         try {
//         // Get existing assessments for this organization
//         const existingData = await netRiskReductionService.getByOrganization(organizationId);

//         // Create initial data structure for all vulnerability-control combinations
//         const initialData: NetRiskReductionData[] = [];

//         overlappingVulnerabilities.forEach(vuln => {
//             controls.forEach(control => {
//             // Check if we already have an assessment for this combination
//             const existing = existingData.assessments?.find(
//                 (assessment: any) => 
//                 assessment.vulnerabilityId?.id === vuln.organizationVulnerability.id &&
//                 assessment.control === control &&
//                 assessment.user?.id === userId
//             );

//             if (existing) {
//                 // Use existing data
//                 initialData.push({
//                 id: existing.id,
//                 vulnerabilityId: vuln.organizationVulnerability.id,
//                 control: control,
//                 riskReductionDegree: existing.riskReductionDegree,
//                 newVulnerabilityPossibility: existing.newVulnerabilityPossibility,
//                 potentialNewRisks: existing.potentialNewRisks,
//                 nrr: totalRisk * existing.riskReductionDegree - existing.newVulnerabilityPossibility * existing.potentialNewRisks
//                 });
//             } else {
//                 // Create empty entry for new combinations
//                 initialData.push({
//                 vulnerabilityId: vuln.organizationVulnerability.id,
//                 control: control,
//                 riskReductionDegree: 0,
//                 newVulnerabilityPossibility: 0,
//                 potentialNewRisks: 0,
//                 nrr: 0
//                 });
//             }
//             });
//         });
//         setRiskData(initialData);

//         } catch (error) {
//         // Create empty structure on error
//         const emptyData: NetRiskReductionData[] = [];
//         overlappingVulnerabilities.forEach(vuln => {
//             controls.forEach(control => {
//             emptyData.push({
//                 vulnerabilityId: vuln.organizationVulnerability.id,
//                 control: control,
//                 riskReductionDegree: 0,
//                 newVulnerabilityPossibility: 0,
//                 potentialNewRisks: 0,
//                 nrr: 0
//             });
//             });
//         });
//         setRiskData(emptyData);
//         } finally {
//         setDataLoading(false);
//         }
//     };

//     loadRiskData();
//     }, [overlappingVulnerabilities, controls, userId, organizationId, totalRisk]);

//   // Helper functions for handling input changes and data retrieval
//   const handleInputChange = (vulnerabilityId: string, control: string, field: string, value: number) => {
//     setRiskData(prev => prev.map(item => {
//       if (item.vulnerabilityId === vulnerabilityId && item.control === control) {
//         const updated = { ...item, [field]: value };
//         // Recalculate NRR when values change
//         updated.nrr = totalRisk * updated.riskReductionDegree - updated.newVulnerabilityPossibility * updated.potentialNewRisks;
//         return updated;
//       }
//       return item;
//     }));
//   };

//   const getRiskDataForCombo = (vulnerabilityId: string, control: string) => {
//     return riskData.find(item => item.vulnerabilityId === vulnerabilityId && item.control === control);
//   };

//   const handleSaveAll = async () => {
//     setSaving(true);
//     try {
//       for (const item of riskData) {
//         // Only save if values are not all zero
//         if (item.riskReductionDegree > 0 || item.newVulnerabilityPossibility > 0 || item.potentialNewRisks > 0) {
//           if (item.id) {
//             // Update existing
//             await netRiskReductionService.update(item.id, {
//               riskReductionDegree: item.riskReductionDegree,
//               newVulnerabilityPossibility: item.newVulnerabilityPossibility,
//               potentialNewRisks: item.potentialNewRisks
//             });
//           } else {
//             // Create new
//             const response = await netRiskReductionService.create({
//               userId: userId,
//               organizationId: organizationId,
//               vulnerabilityId: item.vulnerabilityId,
//               control: item.control,
//               riskReductionDegree: item.riskReductionDegree,
//               newVulnerabilityPossibility: item.newVulnerabilityPossibility,
//               potentialNewRisks: item.potentialNewRisks
//             });
            
//             // Update local state with the new ID
//             setRiskData(prev => prev.map(prevItem => 
//               prevItem.vulnerabilityId === item.vulnerabilityId && prevItem.control === item.control
//                 ? { ...prevItem, id: response.id }
//                 : prevItem
//             ));
//           }
//         }
//       }
//       console.log('‚úÖ All risk assessments saved successfully');
//     } catch (error) {
//       console.error('‚ùå Error saving risk assessments:', error);
//     } finally {
//       setSaving(false);
//     }
//   };

//   if (dataLoading) {
//     return (
//       <Card className="bg-gray-300 text-black p-6">
//         <h2 className="text-xl font-semibold mb-4">Vulnerability-Control Mapping</h2>
//         <div className="text-center py-4">Loading risk assessment data...</div>
//       </Card>
//     );
//   }

//   if (overlappingVulnerabilities.length === 0) {
//     return (
//       <Card className="bg-gray-300 text-black p-6">
//         <h2 className="text-xl font-semibold mb-4">Vulnerability-Control Mapping</h2>
//         <div className="text-center py-4 text-gray-600">
//           No overlapping vulnerabilities found. Risk assessment cannot be performed.
//         </div>
//       </Card>
//     );
//   }

//   if (controls.length === 0) {
//     return (
//       <Card className="bg-gray-300 text-black p-6">
//         <h2 className="text-xl font-semibold mb-4">Vulnerability-Control Mapping</h2>
//         <div className="text-center py-4 text-gray-600">
//           No organization controls found. Please add controls first.
//         </div>
//       </Card>
//     );
//   }

//   return (
//     <Card className="bg-gray-300 text-black p-6">
//       <div className="flex justify-between items-center mb-4">
//         <h2 className="text-xl font-semibold">Vulnerability-Control Mapping</h2>
//         <button
//           onClick={handleSaveAll}
//           disabled={saving}
//           className="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 disabled:bg-gray-400"
//         >
//           {saving ? 'Saving...' : 'Save All Changes'}
//         </button>
//       </div>

//       <p className="mb-4">
//         <strong>Controls in Organization:</strong> {controls.join(", ")}
//       </p>
//       <p className="mb-4">
//         <strong>Overlapping Vulnerabilities:</strong> {overlappingVulnerabilities.length}
//       </p>

//       <div className="overflow-x-auto">
//         <table className="w-full text-sm border border-gray-400">
//           <thead className="bg-gray-200 text-black">
//             <tr>
//               <th className="p-2 border">Vulnerability ID</th>
//               <th className="p-2 border">Affected System</th>
//               <th className="p-2 border">Control Name</th>
//               <th className="p-2 border">Initial Risk ($M)</th>
//               <th className="p-2 border">Risk Reduction Degree (0-1)</th>
//               <th className="p-2 border">New Vulnerability Possibility (0-1)</th>
//               <th className="p-2 border">Potential New Risk (‚â•0)</th>
//               <th className="p-2 border">Net Risk Reduction (NRR)</th>
//             </tr>
//           </thead>
//           <tbody>
//             {overlappingVulnerabilities.map((vuln) => (
//               controls.map((control, controlIndex) => {
//                 const riskItem = getRiskDataForCombo(vuln.organizationVulnerability.id, control);
//                 const isFirstControlForVuln = controlIndex === 0;
                
//                 return (
//                   <tr key={`${vuln.vulnerabilityId}-${control}`}>
//                     {/* Show vulnerability info only for first control */}
//                     {isFirstControlForVuln && (
//                       <>
//                         <td className={`p-2 border font-medium ${controls.length > 1 ? 'border-b-2 border-gray-600' : ''}`} rowSpan={controls.length}>
//                           {vuln.vulnerabilityId}
//                         </td>
//                         <td className={`p-2 border ${controls.length > 1 ? 'border-b-2 border-gray-600' : ''}`} rowSpan={controls.length}>
//                           {vuln.organizationVulnerability.affectedSystem}
//                         </td>
//                       </>
//                     )}
                    
//                     <td className="p-2 border font-medium">{control}</td>
//                     <td className="p-2 border">{totalRisk.toFixed(2)}</td>
                    
//                     {/* Editable inputs */}
//                     <td className="p-2 border">
//                       <input
//                         type="number"
//                         min="0"
//                         max="1"
//                         step="0.1"
//                         value={riskItem?.riskReductionDegree || 0}
//                         onChange={(e) => handleInputChange(
//                           vuln.organizationVulnerability.id,
//                           control,
//                           'riskReductionDegree',
//                           parseFloat(e.target.value) || 0
//                         )}
//                         className="w-full px-2 py-1 border rounded text-center"
//                       />
//                     </td>
                    
//                     <td className="p-2 border">
//                       <input
//                         type="number"
//                         min="0"
//                         max="1"
//                         step="0.1"
//                         value={riskItem?.newVulnerabilityPossibility || 0}
//                         onChange={(e) => handleInputChange(
//                           vuln.organizationVulnerability.id,
//                           control,
//                           'newVulnerabilityPossibility',
//                           parseFloat(e.target.value) || 0
//                         )}
//                         className="w-full px-2 py-1 border rounded text-center"
//                       />
//                     </td>
                    
//                     <td className="p-2 border">
//                       <input
//                         type="number"
//                         min="0"
//                         step="1"
//                         value={riskItem?.potentialNewRisks || 0}
//                         onChange={(e) => handleInputChange(
//                           vuln.organizationVulnerability.id,
//                           control,
//                           'potentialNewRisks',
//                           parseFloat(e.target.value) || 0
//                         )}
//                         className="w-full px-2 py-1 border rounded text-center"
//                       />
//                     </td>
                    
//                     {/* Calculated NRR */}
//                     <td className="p-2 border font-bold bg-blue-50">
//                       {riskItem?.nrr?.toFixed(2) || '0.00'}
//                     </td>
//                   </tr>
//                 );
//               })
//             ))}
//           </tbody>
//         </table>
//       </div>

//       <div className="mt-4 text-sm text-gray-700">
//         <p><strong>Note:</strong> Net Risk Reduction (NRR) = Initial Risk √ó Risk Reduction Degree - New Vulnerability Possibility √ó Potential New Risk</p>
//         <p>Values are automatically saved when you click "Save All Changes"</p>
//       </div>
//     </Card>
//   );
// };

// export default VulnerabilityControlMappingCard;

import React, { useState, useEffect } from 'react';
import { Card } from '@/components/ui/card';
import { OverlappingVulnerability } from '@/types/vulnerabilities';
import { 
    NetRiskReductionData, 
    VulnerabilityControlMappingProps,
    CreateNetRiskReductionRequest 
} from '@/types/netRiskReduction';
import netRiskReductionService from '@/services/netRiskReduction';

// Add onDataChange to the props interface
const VulnerabilityControlMappingCard: React.FC<VulnerabilityControlMappingProps> = ({
  overlappingVulnerabilities,
  controls,
  userId,
  organizationId,
  totalRisk,
  loading = false,
  onDataChange // Add this prop
}) => {
  const [riskData, setRiskData] = useState<NetRiskReductionData[]>([]);
  const [saving, setSaving] = useState(false);
  const [dataLoading, setDataLoading] = useState(true);

  const updateRiskData = (newData: NetRiskReductionData[]) => {
    setRiskData(newData);
    onDataChange?.(newData); // Notify parent component
  };

  useEffect(() => {
    const loadRiskData = async () => {
        // Only run if we have the required data
        if (!userId || !organizationId || overlappingVulnerabilities.length === 0 || controls.length === 0) {
        console.log('‚è∏Ô∏è Skipping risk data load - missing required data:', {
            userId: !!userId,
            organizationId: !!organizationId, 
            vulnerabilitiesCount: overlappingVulnerabilities.length,
            controlsCount: controls.length
        });
        setDataLoading(false);
        return;
        }

        setDataLoading(true);
        console.log('üîç Loading risk data...');

        try {
        // Get existing assessments for this organization
        const existingData = await netRiskReductionService.getByOrganization(organizationId);
        console.log('üì¶ Existing assessments:', existingData);

        // Create initial data structure for all vulnerability-control combinations
        const initialData: NetRiskReductionData[] = [];

        overlappingVulnerabilities.forEach(vuln => {
            controls.forEach(control => {
            // Check if we already have an assessment for this combination
            const existing = existingData.assessments?.find(
                (assessment: any) => 
                assessment.vulnerabilityId?.id === vuln.organizationVulnerability.id &&
                assessment.control === control &&
                assessment.user?.id === userId
            );

            if (existing) {
                console.log(`‚úÖ Found existing assessment: ${vuln.vulnerabilityId} + ${control}`);
                // Use existing data
                initialData.push({
                id: existing.id,
                vulnerabilityId: vuln.organizationVulnerability.id,
                control: control,
                riskReductionDegree: existing.riskReductionDegree,
                newVulnerabilityPossibility: existing.newVulnerabilityPossibility,
                potentialNewRisks: existing.potentialNewRisks,
                nrr: totalRisk * existing.riskReductionDegree - existing.newVulnerabilityPossibility * existing.potentialNewRisks
                });
            } else {
                console.log(`‚ûï Creating empty entry: ${vuln.vulnerabilityId} + ${control}`);
                // Create empty entry for new combinations
                initialData.push({
                vulnerabilityId: vuln.organizationVulnerability.id,
                control: control,
                riskReductionDegree: 0,
                newVulnerabilityPossibility: 0,
                potentialNewRisks: 0,
                nrr: 0
                });
            }
            });
        });

        console.log('üìä Final risk data loaded:', initialData);
        updateRiskData(initialData);

        } catch (error) {
        console.error('‚ùå Error loading risk data:', error);
        
        // Create empty structure on error
        const emptyData: NetRiskReductionData[] = [];
        overlappingVulnerabilities.forEach(vuln => {
            controls.forEach(control => {
            emptyData.push({
                vulnerabilityId: vuln.organizationVulnerability.id,
                control: control,
                riskReductionDegree: 0,
                newVulnerabilityPossibility: 0,
                potentialNewRisks: 0,
                nrr: 0
            });
            });
        });
        setRiskData(emptyData);
        } finally {
        setDataLoading(false);
        }
    };

    loadRiskData();
    }, [overlappingVulnerabilities, controls, userId, organizationId, totalRisk]);

  // Helper functions for handling input changes and data retrieval
  const handleInputChange = (vulnerabilityId: string, control: string, field: string, value: number) => {
    const newData = riskData.map(item => {
      if (item.vulnerabilityId === vulnerabilityId && item.control === control) {
        const updated = { ...item, [field]: value };
        // Recalculate NRR when values change
        updated.nrr = totalRisk * updated.riskReductionDegree - updated.newVulnerabilityPossibility * updated.potentialNewRisks;
        return updated;
      }
      return item;
    });
    updateRiskData(newData); // Use updateRiskData instead of setRiskData
  };

  const getRiskDataForCombo = (vulnerabilityId: string, control: string) => {
    return riskData.find(item => item.vulnerabilityId === vulnerabilityId && item.control === control);
  };

  const handleSaveAll = async () => {
    setSaving(true);
    try {
      for (const item of riskData) {
        // Only save if values are not all zero
        if (item.riskReductionDegree > 0 || item.newVulnerabilityPossibility > 0 || item.potentialNewRisks > 0) {
          if (item.id) {
            // Update existing
            await netRiskReductionService.update(item.id, {
              riskReductionDegree: item.riskReductionDegree,
              newVulnerabilityPossibility: item.newVulnerabilityPossibility,
              potentialNewRisks: item.potentialNewRisks
            });
          } else {
            // Create new
            const response = await netRiskReductionService.create({
              userId: userId,
              organizationId: organizationId,
              vulnerabilityId: item.vulnerabilityId,
              control: item.control,
              riskReductionDegree: item.riskReductionDegree,
              newVulnerabilityPossibility: item.newVulnerabilityPossibility,
              potentialNewRisks: item.potentialNewRisks
            });
            
            // Update local state with the new ID
            setRiskData(prev => prev.map(prevItem => 
              prevItem.vulnerabilityId === item.vulnerabilityId && prevItem.control === item.control
                ? { ...prevItem, id: response.id }
                : prevItem
            ));
          }
        }
      }
      console.log('‚úÖ All risk assessments saved successfully');
    } catch (error) {
      console.error('‚ùå Error saving risk assessments:', error);
    } finally {
      setSaving(false);
    }
  };

  if (dataLoading) {
    return (
      <Card className="bg-gray-300 text-black p-6">
        <h2 className="text-xl font-semibold mb-4">Vulnerability-Control Mapping</h2>
        <div className="text-center py-4">Loading risk assessment data...</div>
      </Card>
    );
  }

  if (overlappingVulnerabilities.length === 0) {
    return (
      <Card className="bg-gray-300 text-black p-6">
        <h2 className="text-xl font-semibold mb-4">Vulnerability-Control Mapping</h2>
        <div className="text-center py-4 text-gray-600">
          No overlapping vulnerabilities found. Risk assessment cannot be performed.
        </div>
      </Card>
    );
  }

  if (controls.length === 0) {
    return (
      <Card className="bg-gray-300 text-black p-6">
        <h2 className="text-xl font-semibold mb-4">Vulnerability-Control Mapping</h2>
        <div className="text-center py-4 text-gray-600">
          No organization controls found. Please add controls first.
        </div>
      </Card>
    );
  }

  return (
    <Card className="bg-gray-300 text-black p-6">
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-xl font-semibold">Vulnerability-Control Mapping</h2>
        <button
          onClick={handleSaveAll}
          disabled={saving}
          className="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 disabled:bg-gray-400"
        >
          {saving ? 'Saving...' : 'Save All Changes'}
        </button>
      </div>

      <p className="mb-4">
        <strong>Controls in Organization:</strong> {controls.join(", ")}
      </p>
      <p className="mb-4">
        <strong>Overlapping Vulnerabilities:</strong> {overlappingVulnerabilities.length}
      </p>

      <div className="overflow-x-auto">
        <table className="w-full text-sm border border-gray-400">
          <thead className="bg-gray-200 text-black">
            <tr>
              <th className="p-2 border">Vulnerability ID</th>
              <th className="p-2 border">Affected System</th>
              <th className="p-2 border">Control Name</th>
              <th className="p-2 border">Initial Risk ($M)</th>
              <th className="p-2 border">Risk Reduction Degree (0-1)</th>
              <th className="p-2 border">New Vulnerability Possibility (0-1)</th>
              <th className="p-2 border">Potential New Risk (‚â•0)</th>
              <th className="p-2 border">Net Risk Reduction (NRR)</th>
            </tr>
          </thead>
          <tbody>
            {overlappingVulnerabilities.map((vuln) => (
              controls.map((control, controlIndex) => {
                const riskItem = getRiskDataForCombo(vuln.organizationVulnerability.id, control);
                const isFirstControlForVuln = controlIndex === 0;
                
                return (
                  <tr key={`${vuln.vulnerabilityId}-${control}`}>
                    {/* Show vulnerability info only for first control */}
                    {isFirstControlForVuln && (
                      <>
                        <td className={`p-2 border font-medium ${controls.length > 1 ? 'border-b-2 border-gray-600' : ''}`} rowSpan={controls.length}>
                          {vuln.vulnerabilityId}
                        </td>
                        <td className={`p-2 border ${controls.length > 1 ? 'border-b-2 border-gray-600' : ''}`} rowSpan={controls.length}>
                          {vuln.organizationVulnerability.affectedSystem}
                        </td>
                      </>
                    )}
                    
                    <td className="p-2 border font-medium">{control}</td>
                    <td className="p-2 border">{totalRisk.toFixed(2)}</td>
                    
                    {/* Editable inputs */}
                    <td className="p-2 border">
                      <input
                        type="number"
                        min="0"
                        max="1"
                        step="0.1"
                        value={riskItem?.riskReductionDegree || 0}
                        onChange={(e) => handleInputChange(
                          vuln.organizationVulnerability.id,
                          control,
                          'riskReductionDegree',
                          parseFloat(e.target.value) || 0
                        )}
                        className="w-full px-2 py-1 border rounded text-center"
                      />
                    </td>
                    
                    <td className="p-2 border">
                      <input
                        type="number"
                        min="0"
                        max="1"
                        step="0.1"
                        value={riskItem?.newVulnerabilityPossibility || 0}
                        onChange={(e) => handleInputChange(
                          vuln.organizationVulnerability.id,
                          control,
                          'newVulnerabilityPossibility',
                          parseFloat(e.target.value) || 0
                        )}
                        className="w-full px-2 py-1 border rounded text-center"
                      />
                    </td>
                    
                    <td className="p-2 border">
                      <input
                        type="number"
                        min="0"
                        step="1"
                        value={riskItem?.potentialNewRisks || 0}
                        onChange={(e) => handleInputChange(
                          vuln.organizationVulnerability.id,
                          control,
                          'potentialNewRisks',
                          parseFloat(e.target.value) || 0
                        )}
                        className="w-full px-2 py-1 border rounded text-center"
                      />
                    </td>
                    
                    {/* Calculated NRR */}
                    <td className="p-2 border font-bold bg-blue-50">
                      {riskItem?.nrr?.toFixed(2) || '0.00'}
                    </td>
                  </tr>
                );
              })
            ))}
          </tbody>
        </table>
      </div>

      <div className="mt-4 text-sm text-gray-700">
        <p><strong>Note:</strong> Net Risk Reduction (NRR) = Initial Risk √ó Risk Reduction Degree - New Vulnerability Possibility √ó Potential New Risk</p>
        <p>Values are automatically saved when you click "Save All Changes"</p>
      </div>
    </Card>
  );
};

export default VulnerabilityControlMappingCard;